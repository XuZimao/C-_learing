#C++类型推导和优先级
***

##类型别名
>**类型别名指把已经定义的数据类型换个新的名字。**  

###1.typedef关键词	
>**使用方法如下**  

	typedef double price;  //price是double的一个类型别名
	//将double->price(左给右)
>>**将double类型定义一个新名字price且在之后可以直接使用price**  

	price car=1.0E5,mobile=100;  //car和mobile都是double类型
###2. using关键字
>**使用方法如下**  

	using price=double;  //price是double的一个类型别名 
	//将double->price(右给左，赋值号=规则) 

>>using关键字和typedef关键字有同样的功能，using关键字紧跟别名和=，**将=左侧的名字（新定义的）声明为=右侧类型（原本的）的别名。**
>>>更推荐使用using方法。此方法和定义对象的方式类似。（右给左）
***
##auto类型推导
>在此之前定义一个对象（初始化）时，需要进行类型说明。
>如`double pi=3.14;`  这种定义法叫做显式指明数据类型。

###1.auto关键字
>编译器可以将auto关键字后的初始值自动识别出需要的数据类型（**利用表达式的值自动推导出用户想到定义的对象的数据类型，并用表达式的值初始化定义的对象**）。如下：  

	auto pi=3.14159,rad=1.0;  //自动识别为double类型
	auto area=pi*rad*rad;  //area为double类型
>>用auto关键字时，必须为对象提供一个初始值，否则无法识别！  
>>例如：`auto i;  //对象i未初始化`

>当初始值是一个const对象时，auto将忽略const属性。如下：  
>  
	const double pi=3.14159;
	auto rad=pi;  //rad是double类型，const属性被忽略。
>如果希望将rad具有const属性，则需要显式指出，如下：  
>
	const auto rad=pi;  //rad是const double类型
>当auto后面有多个对象时，其类型必须保持一致，否则报错   
	
	auto i=0,pi=3.14159;  //错误：i和pi的类型不一样 


###2.decltype关键字
>该关键字可以在不使用计算表达式的情况下获取表达式的数据类型，语法格式为decltype(expr)，如下：  
>（当用户只想用表达式的类型而不想用表达式的值来定义对象时适用，**会根据括号来推导后面对象的类型**）
>	
	int i=0;
	decltype (i) j=1;  //由于i为整型，因此j为int类型
	decltype (i+j) k=0;  //由于i+j为整型，因此k为int类型
	//decltype分析i+j得到值的数据类型，但不会计算i+j的具体值
>当decltype遇到const时，不会忽略const的属性，如下：  
>
	const double pi=3.14159;
	decltype (pi) rad=1.0;  //rad为const double类型
***
##表达式
>表达式是指由运算符和操作对象组成的式子（算式）。任何一个表达式都有一个确定数据类型的值。表达式求值遵循**运算符的优先级**、**结合性**和**求值次序**

###1.左值和右值  
任何一个表达式，**不是左值就是右值**。左值所在的内存空间可以获取；右值无法获取。**左值既可以读又可以写**；**右值只能读**。定义的用来存放并能够改变值的对象就是左值。**右值只能放在=右边**；左值随意。如下：  
	
>	
	int i=0;  //i为左值，0为右值。用右值初始化左值对象i
	10=i; //错误！左边必须为左值，常量都是右值
	int j=i;  //左值i可以当作右值，只对其进行读操作
	const int N=100; //const后，N变为常量100，成为右值
	N=40;  //错误！不能对右值进行写操作（修改）		
>左值由程序员创建，具有持久性。右值对象在执行运算过程后就消亡，没有持久性。（右值是临时变量） 

###2.优先级和结合性
>复合运算表达式利用优先级和结合性来进行运算，**先乘除后加减**  
>注意括号不受优先级和结合性的约束，先算括号内的再算括号外的。
>常用优先级如下：   
1. ++a/--a/+a/-a  
2. *或/或%  
3. +或-或<<或>>  
4. <或<=或>或>=
5. ==或!=  
6. &(位与)或^(位异或)或|(位或)  
7. &&（and）或||(or)  
8. =  